<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Multi-Device Audio Router v5 (Safe + Low-Latency)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .vu-bar {
      height: 6px; border-radius: 4px;
      background: linear-gradient(to right, #22c55e, #facc15, #ef4444);
      transition: width 60ms linear;
    }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen p-6">
  <div class="max-w-5xl mx-auto space-y-6">
    <h1 class="text-3xl font-bold text-center">🎛 Multi-Device Audio Router v5</h1>

    <!-- Global Controls -->
    <div class="flex flex-wrap justify-center gap-3">
      <button id="startCapture" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 shadow">Start Capture</button>
      <button id="stopCapture"  class="px-4 py-2 rounded-xl bg-rose-600 hover:bg-rose-500 shadow">Stop Capture</button>
      <button id="addRoute"     class="px-4 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 shadow">+ Add Route</button>
      <button id="playAll"      class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 shadow">▶ Play All</button>
      <button id="stopAll"      class="px-4 py-2 rounded-xl bg-gray-700 hover:bg-gray-600 shadow">■ Stop All</button>
      <button id="refreshDevices" class="px-4 py-2 rounded-xl bg-amber-600 hover:bg-amber-500 shadow">🔄 Refresh Devices</button>
    </div>

    <p id="info" class="text-center text-gray-400"></p>
    <p id="warn" class="text-center text-amber-400 text-sm"></p>

    <!-- Routes -->
    <div id="routes" class="grid md:grid-cols-2 gap-6"></div>
  </div>

<script>
/* =========================
   State & Utilities
========================= */
let ac = null;
let srcNode = null;
let stream = null;
let devices = [];
const routes = [];
const defaultGuard = true; // prevent echo on default/system sink

const infoEl = document.getElementById('info');
const warnEl = document.getElementById('warn');

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

/* =========================
   AudioWorklet: Limiter + Meter
========================= */
const workletCode = `
class LimiterProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [
      { name: 'preGain', defaultValue: 1.0, minValue: 0.0, maxValue: 8.0, automationRate: 'a-rate' },
      { name: 'threshold', defaultValue: 0.95, minValue: 0.5, maxValue: 1.2, automationRate: 'a-rate' },
      { name: 'release', defaultValue: 0.005, minValue: 0.001, maxValue: 0.1, automationRate: 'k-rate' }
    ];
  }
  constructor(options) {
    super(options);
    this._rmsAccum = 0;
    this._rmsCount = 0;
    this._lastGain = 1.0;
    this._meterInterval = 128;
    this._framesSincePost = 0;
  }
  process(inputs, outputs, parameters) {
    const input = inputs[0];
    const output = outputs[0];
    if (!input || input.length === 0) return true;
    const ch = Math.min(input.length, output.length);

    const preGain = parameters.preGain.length === 1 ? parameters.preGain[0] : 1.0;
    const threshold = parameters.threshold.length === 1 ? parameters.threshold[0] : 0.95;
    const rel = parameters.release.length === 1 ? parameters.release[0] : 0.005;

    for (let c = 0; c < ch; c++) {
      const inp = input[c];
      const out = output[c];
      for (let i = 0; i < inp.length; i++) {
        let s = inp[i] * preGain;

        const abs = Math.abs(s);
        if (abs > threshold) {
          const over = abs - threshold;
          s = Math.sign(s) * (threshold + over / (1 + over * 8));
        }

        const g = Math.min(1, threshold / Math.max(threshold, Math.abs(s)));
        this._lastGain = this._lastGain + (g - this._lastGain) * rel;
        const y = s * this._lastGain;

        out[i] = y;

        this._rmsAccum += y * y;
        this._rmsCount++;

        if (++this._framesSincePost >= this._meterInterval) {
          const rms = Math.sqrt(this._rmsAccum / this._rmsCount);
          this.port.postMessage({ rms });
          this._rmsAccum = 0;
          this._rmsCount = 0;
          this._framesSincePost = 0;
        }
      }
    }
    return true;
  }
}
registerProcessor('limiter-processor', LimiterProcessor);
`;

async function ensureWorkletLoaded() {
  if (!ac) return;
  if (!ac._limiterLoaded) {
    const blob = new Blob([workletCode], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await ac.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);
    ac._limiterLoaded = true;
  }
}

/* =========================
   Device Management
========================= */
async function refreshDevices() {
  try {
    devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'audiooutput');
    const noLabels = devices.length && !devices.some(d => d.label && d.label.trim());
    warnEl.textContent = noLabels
      ? 'Tip: To show device names, grant microphone permission once (labels are hidden otherwise).'
      : '';
    document.querySelectorAll('.deviceSelect').forEach(sel => {
      const current = sel.value;
      sel.innerHTML = '';
      for (const d of devices) {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Device ${d.deviceId}`;
        sel.appendChild(opt);
      }
      if ([...sel.options].some(o => o.value === current)) sel.value = current;
    });
  } catch (e) {
    console.error(e);
    warnEl.textContent = 'Failed to enumerate audio outputs. Use a Chromium-based browser and a secure context (https).';
  }
}

navigator.mediaDevices?.addEventListener('devicechange', refreshDevices);

/* =========================
   Capture Management
========================= */
async function startCapture() {
  if (stream) return;

  try {
    stream = await navigator.mediaDevices.getDisplayMedia({
      video: true,
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });
  } catch (e) {
    warnEl.textContent = 'Screen/audio capture was blocked or failed.';
    console.error(e);
    return;
  }

  // Stop video to reduce overhead
  stream.getVideoTracks().forEach(t => t.stop());

  // Fresh low-latency context
  ac = new (window.AudioContext || window.webkitAudioContext)({
    latencyHint: 'interactive',
    sampleRate: 48000
  });

  await ensureWorkletLoaded();

  srcNode = ac.createMediaStreamSource(stream);

  infoEl.textContent = `Capturing @ ${ac.sampleRate} Hz • Output latency: ${Math.round((ac.outputLatency || 0) * 1000)} ms`;

  // Nudge autoplay policies
  try { await ac.resume(); } catch {}

  // One-shot mic permission to unlock labels
  try {
    const mic = await navigator.mediaDevices.getUserMedia({ audio: true });
    mic.getTracks().forEach(t => t.stop());
  } catch {}
  await refreshDevices();
}

function stopCapture() {
  if (!stream && !ac) return;

  try { stream?.getTracks().forEach(t => t.stop()); } catch {}
  stream = null;

  try { srcNode?.disconnect(); } catch {}
  srcNode = null;

  // stop all routes and disconnect
  routes.splice(0).forEach(r => {
    try { r.audioEl.pause(); } catch {}
    try { r.lim.disconnect(); } catch {}
    try { r.hp.disconnect(); } catch {}
    try { r.d.disconnect(); } catch {}
    try { r.g.disconnect(); } catch {}
  });

  if (ac) {
    const ctx = ac;
    ac = null;
    ctx.close().catch(()=>{});
  }

  infoEl.textContent = 'Capture stopped.';
}

/* =========================
   Helpers for sinks & play
========================= */
async function bindSink(audioEl, deviceId, allowDefault) {
  if (!audioEl.setSinkId) {
    alert('setSinkId is not supported in this browser (try Chromium-based).');
    throw new Error('No setSinkId');
  }
  if (!allowDefault && defaultGuard && (deviceId === 'default' || deviceId === '')) {
    throw new Error('Default sink guarded');
  }
  await audioEl.setSinkId(deviceId);
}

async function robustPlay(audioEl) {
  // Prime muted to satisfy autoplay, then unmute
  audioEl.muted = true;
  try {
    await audioEl.play();
  } catch (e) {
    // Try resume context and retry once
    try { await ac?.resume(); } catch {}
    await sleep(10);
    await audioEl.play();
  }
  // small delay to allow device ramp-up, then unmute
  await sleep(50);
  audioEl.muted = false;
}

/* =========================
   Route Creation
========================= */
async function createRoute() {
  if (!stream || !ac || !srcNode) {
    alert('Start capture first!');
    return;
  }

  const g = ac.createGain();
  const d = ac.createDelay(2.0);

  // High-pass filter to reduce low rumble
  const hp = ac.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 40;

  // Worklet Limiter (also provides RMS metering)
  const limiter = new AudioWorkletNode(ac, 'limiter-processor', {
    numberOfInputs: 1,
    numberOfOutputs: 1,
    outputChannelCount: [2],
    parameterData: { preGain: 1.0, threshold: 0.96, release: 0.01 }
  });

  const dst = ac.createMediaStreamDestination();

  // Graph: src -> gain -> delay -> highpass -> limiter -> destination
  srcNode.connect(g).connect(d).connect(hp).connect(limiter).connect(dst);

  // audio element sink
  const audioEl = new Audio();
  // give each element its own stream object (avoid shared refs)
  const track = dst.stream.getAudioTracks()[0];
  audioEl.srcObject = new MediaStream([track]);
  audioEl.loop = true;
  audioEl.autoplay = false;
  audioEl.playsInline = true;
  audioEl.preload = 'auto';
  audioEl.crossOrigin = 'anonymous';

  // UI card
  const id = Date.now() + Math.random();
  const wrapper = document.createElement('div');
  wrapper.className = 'p-4 rounded-2xl bg-gray-800 shadow-xl space-y-3';
  wrapper.id = `route-${id}`;

  wrapper.innerHTML = `
    <h2 class="text-lg font-semibold">🔊 Route</h2>

    <label class="block text-sm">Device:
      <select class="deviceSelect w-full mt-1 p-2 rounded bg-gray-700"></select>
    </label>

    <div class="grid grid-cols-2 gap-3">
      <label class="block text-sm">Gain
        <input type="range" min="0" max="200" value="100" class="gainSlider w-full">
      </label>
      <label class="block text-sm">Delay (ms)
        <input type="number" min="0" max="2000" value="0" class="delayInput w-full text-black rounded">
      </label>
    </div>

    <div class="grid grid-cols-2 gap-3">
      <label class="block text-sm">Limiter Pre-Gain
        <input type="range" min="50" max="200" value="100" class="preGainSlider w-full">
      </label>
      <label class="block text-sm">Hi-Pass (Hz)
        <input type="number" min="20" max="200" value="40" class="hipassInput w-full text-black rounded">
      </label>
    </div>

    <div class="flex items-center gap-2">
      <input type="checkbox" class="allowDefault">
      <span class="text-sm text-gray-400">Allow default/system sink (unsafe)</span>
    </div>

    <div class="h-2 bg-gray-700 rounded"><div class="vu-bar w-0"></div></div>

    <div class="flex gap-2">
      <button class="play px-3 py-1 rounded bg-green-600 hover:bg-green-500">▶</button>
      <button class="pause px-3 py-1 rounded bg-yellow-600 hover:bg-yellow-500">⏸</button>
      <button class="remove px-3 py-1 rounded bg-red-600 hover:bg-red-500">🗑</button>
    </div>
  `;

  document.getElementById('routes').appendChild(wrapper);

  // Populate device list
  const select = wrapper.querySelector('.deviceSelect');
  for (const dvc of devices) {
    const opt = document.createElement('option');
    opt.value = dvc.deviceId;
    opt.textContent = dvc.label || `Device ${dvc.deviceId}`;
    select.appendChild(opt);
  }

  // Prefer a non-default to avoid echo by default
  if (select.options.length > 0) {
    const firstNonDefault = [...select.options].find(o => o.value !== 'default' && o.value !== '');
    select.value = firstNonDefault ? firstNonDefault.value : select.options[0].value;
  }

  // Device change handler with guard
  select.onchange = async () => {
    const allowDefault = wrapper.querySelector('.allowDefault').checked;
    const sel = select.value;
    try {
      await bindSink(audioEl, sel, allowDefault);
    } catch (e) {
      console.error('setSinkId failed:', e);
      alert('Could not switch output to the selected device. It may be blocked by the browser or guarded.');
    }
  };

  wrapper.querySelector('.allowDefault').onchange = () => select.onchange();

  // Controls
  wrapper.querySelector('.gainSlider').oninput = e => g.gain.value = e.target.value / 100;
  wrapper.querySelector('.delayInput').oninput = e => d.delayTime.value = Math.min(2, Math.max(0, Number(e.target.value)/1000));
  wrapper.querySelector('.preGainSlider').oninput = e => limiter.parameters.get('preGain').setValueAtTime(Number(e.target.value)/100, ac.currentTime);
  wrapper.querySelector('.hipassInput').oninput = e => hp.frequency.value = Math.min(200, Math.max(20, Number(e.target.value)||40));

  wrapper.querySelector('.play').onclick = async () => {
    try { await robustPlay(audioEl); } catch (e) { console.error(e); alert('Autoplay blocked. Click again after interacting with the page.'); }
  };
  wrapper.querySelector('.pause').onclick = () => audioEl.pause();
  wrapper.querySelector('.remove').onclick = () => {
    try { audioEl.pause(); } catch {}
    try { limiter.disconnect(); } catch {}
    try { hp.disconnect(); } catch {}
    try { g.disconnect(); } catch {}
    try { d.disconnect(); } catch {}
    wrapper.remove();
    const idx = routes.findIndex(r => r.id === id);
    if (idx >= 0) routes.splice(idx, 1);
  };

  // Meter hookup
  const bar = wrapper.querySelector('.vu-bar');
  limiter.port.onmessage = (ev) => {
    const rms = ev.data?.rms ?? 0;
    const pct = Math.min(100, Math.max(0, Math.sqrt(rms) * 150));
    bar.style.width = pct + '%';
  };

  // Add to registry
  routes.push({ id, g, d, hp, lim: limiter, dst, audioEl, select });

  // Bind the initial sink and keep paused until user presses play
  if (select.value) {
    try { await bindSink(audioEl, select.value, wrapper.querySelector('.allowDefault').checked); } catch {}
  }
}

/* =========================
   Global bindings
========================= */
document.getElementById('startCapture').onclick = startCapture;
document.getElementById('stopCapture').onclick  = stopCapture;
document.getElementById('addRoute').onclick     = createRoute;

document.getElementById('playAll').onclick      = async () => {
  // Ensure each route is bound to its sink first
  for (const r of routes) {
    try {
      await bindSink(r.audioEl, r.select.value, r.select.closest('div').querySelector('.allowDefault').checked);
    } catch (e) { console.warn('Sink bind skipped for a route:', e); }
  }
  // Play sequentially to satisfy autoplay policies & device ramp-up
  for (const r of routes) {
    try { await robustPlay(r.audioEl); } catch (e) { console.error('Play failed for a route', e); }
    await sleep(40); // tiny stagger reduces contention
  }
};

document.getElementById('stopAll').onclick      = () => routes.forEach(r => { try { r.audioEl.pause(); } catch {} });
document.getElementById('refreshDevices').onclick = refreshDevices;

// Initial
refreshDevices();
</script>
</body>
</html>
